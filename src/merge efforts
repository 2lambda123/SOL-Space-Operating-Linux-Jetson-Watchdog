/* Function that merges two structs, with the second struct overriding the first if there's a conflict */
fn merge(a: &mut Value, b: &Value) {
    match (a, b) {
        (&mut Value::Object(ref mut a), &Value::Object(ref b)) => {  // If there are objects in both, then clone a's key and send a call to recurse
        
            for (k, v) in b {
                merge(a.entry(k.clone()).or_insert(Value::Null), v);
            }
        }
        (a, b) => { // upon recursing, if a has that key, then it receives a copy of b's 
            let mut a_vec: Vec<_> = vec![a.clone()].as_slice().to_vec();
            let mut b_vec: Vec<_> = vec![b.clone()].as_slice().to_vec();   
            if a.is_array() {
                a_vec = a.as_array().unwrap().to_vec();
            }
            if b.is_array() {
                b_vec = b.as_array().unwrap().to_vec();
            }
            if !b.is_null(){
                a_vec.append(&mut b_vec); //works but not completely
                // a_vec.sort();
                a_vec.dedup();
                *a = serde_json::to_value(a_vec).unwrap();
            }
        }
    }
}